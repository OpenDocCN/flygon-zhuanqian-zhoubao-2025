<h1>如何利用cursor实现文章中自动批量插入图片</h1>
<blockquote>来源：<a href="https://si06f5z4e71.feishu.cn/docx/UD7vd0bajo0Z56xhirCcyB2bnZd">https://si06f5z4e71.feishu.cn/docx/UD7vd0bajo0Z56xhirCcyB2bnZd</a></blockquote>
<h1>代运营批量文章插入图片是一个痛点</h1>
<p>公众号代运营在文章中自动插入图片是一个痛点，也是我的一个痛点，通过对cursor学习以后，我实现了文章的插图和自动排版。主要是利用了两个点：</p>
<p>1.先将图片链接插入到txt文档中</p>
<p>2.将图片转换为html格式</p>
<p>3.在96编辑器做还原（这里主要是借鉴了猫哥的方式）</p>
<p>4.运行后，可以看到GUI界面，</p>
<p>注意每个文档是一篇文章的图片链接，然后根据文章文件名称和图片的文件名称对应匹配插入。</p>

<p>文末有脚本的源代码，大家自行下载使用！</p>
<p><img src="img/5355e558625b6b0139162ea99f54705e.png" data-original-src="https://internal-api-drive-stream.feishu.cn/space/api/box/stream/download/v2/cover/PiVwbK6KdohZYux1IivcOHz4nMh/"/></p>

<p>import os</p>
<p>import random</p>
<p>import tkinter as tk</p>
<p>from tkinter import filedialog, ttk, messagebox</p>

<p>def insert_images_into_text(text_file_path, image_links_file_path, output_file_path):</p>
<p>try:</p>
<p># 读取文章内容，保持原有格式</p>
<p>with open(text_file_path, 'r', encoding='utf-8') as f:</p>
<p>text_content = f.read()</p>
<p># 读取图片链接并去重</p>
<p>with open(image_links_file_path, 'r', encoding='utf-8') as f:</p>
<p>image_links = []</p>
<p>used_links = set()</p>
<p>for line in f:</p>
<p>link = line.strip()</p>
<p>if link and link not in used_links:</p>
<p>image_links.append(link)</p>
<p>used_links.add(link)</p>
<p># 随机选取3-5张图片</p>
<p>if len(image_links) &gt; 5:</p>
<p>num_images = random.randint(3, 5)</p>
<p>image_links = random.sample(image_links, num_images)</p>
<p>elif len(image_links) &gt; 3:</p>
<p>num_images = random.randint(3, len(image_links))</p>
<p>image_links = random.sample(image_links, num_images)</p>
<p># 如果图片数量小于等于3，保持所有图片</p>
<p># 将文章分割成段落，保持原有的换行符</p>
<p>paragraphs = text_content.split('\n')</p>
<p># 计算插入位置</p>
<p># 只计算非空段落的数量来确定图片位置</p>
<p>non_empty_paragraphs = [i for i, p in enumerate(paragraphs) if p.strip()]</p>
<p>total_paragraphs = len(non_empty_paragraphs)</p>
<p>total_images = len(image_links)</p>
<p>insert_positions = []</p>
<p>if total_images &gt; 0:</p>
<p>step = total_paragraphs / (total_images + 1)</p>
<p>for i in range(total_images):</p>
<p>pos = non_empty_paragraphs[int(step * (i + 1))]</p>
<p>if pos &gt;= len(paragraphs):</p>
<p>break</p>
<p>insert_positions.append(pos)</p>
<p># 插入图片</p>
<p>final_content = []</p>
<p>image_index = 0</p>
<p>for i, paragraph in enumerate(paragraphs):</p>
<p>final_content.append(paragraph)</p>
<p>if i in insert_positions and image_index &lt; len(image_links):</p>
<p>final_content.append('')  # 图片前的空行</p>
<p>final_content.append(image_links[image_index])</p>
<p>final_content.append('')  # 图片后的空行</p>
<p>image_index += 1</p>
<p># 写入新文件</p>
<p>with open(output_file_path, 'w', encoding='utf-8') as f:</p>
<p>f.write('\n'.join(final_content))</p>
<p>return "success"</p>
<p>except Exception as e:</p>
<p>return f"error: {str(e)}"</p>

<p>class ImageInserterGUI:</p>
<p>def __init__(self, root):</p>
<p>self.root = root</p>
<p>self.root.title("文章图片插入工具")</p>
<p>self.root.geometry("800x600")</p>
<p># 创建主框架</p>
<p>self.main_frame = ttk.Frame(root, padding="10")</p>
<p>self.main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))</p>
<p># 文件夹选择区域</p>
<p>self.create_folder_selection()</p>
<p># 日志显示区域</p>
<p>self.create_log_area()</p>
<p># 执行按钮</p>
<p>self.create_execute_button()</p>
<p>def create_folder_selection(self):</p>
<p># 文章文件夹选择</p>
<p>ttk.Label(self.main_frame, text="文章文件夹:").grid(row=0, column=0, sticky=tk.W, pady=5)</p>
<p>self.articles_path = tk.StringVar()</p>
<p>ttk.Entry(self.main_frame, textvariable=self.articles_path, width=60).grid(row=0, column=1, pady=5)</p>
<p>ttk.Button(self.main_frame, text="浏览", command=lambda: self.browse_folder(self.articles_path)).grid(row=0, column=2, padx=5, pady=5)</p>
<p># 图片链接文件夹选择</p>
<p>ttk.Label(self.main_frame, text="图片链接文件夹:").grid(row=1, column=0, sticky=tk.W, pady=5)</p>
<p>self.images_path = tk.StringVar()</p>
<p>ttk.Entry(self.main_frame, textvariable=self.images_path, width=60).grid(row=1, column=1, pady=5)</p>
<p>ttk.Button(self.main_frame, text="浏览", command=lambda: self.browse_folder(self.images_path)).grid(row=1, column=2, padx=5, pady=5)</p>
<p># 输出文件夹选择</p>
<p>ttk.Label(self.main_frame, text="输出文件夹:").grid(row=2, column=0, sticky=tk.W, pady=5)</p>
<p>self.output_path = tk.StringVar()</p>
<p>ttk.Entry(self.main_frame, textvariable=self.output_path, width=60).grid(row=2, column=1, pady=5)</p>
<p>ttk.Button(self.main_frame, text="浏览", command=lambda: self.browse_folder(self.output_path)).grid(row=2, column=2, padx=5, pady=5)</p>
<p>def create_log_area(self):</p>
<p># 创建日志显示区域</p>
<p>log_frame = ttk.LabelFrame(self.main_frame, text="处理日志", padding="5")</p>
<p>log_frame.grid(row=3, column=0, columnspan=3, sticky=(tk.W, tk.E, tk.N, tk.S), pady=10)</p>
<p>self.log_text = tk.Text(log_frame, height=20, width=80)</p>
<p>self.log_text.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))</p>
<p>scrollbar = ttk.Scrollbar(log_frame, orient=tk.VERTICAL, command=self.log_text.yview)</p>
<p>scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))</p>
<p>self.log_text['yscrollcommand'] = scrollbar.set</p>
<p>def create_execute_button(self):</p>
<p># 创建执行按钮</p>
<p>ttk.Button(self.main_frame, text="开始处理", command=self.execute_process).grid(row=4, column=0, columnspan=3, pady=10)</p>
<p>def browse_folder(self, string_var):</p>
<p>folder_path = filedialog.askdirectory()</p>
<p>if folder_path:</p>
<p>string_var.set(folder_path)</p>
<p>def log(self, message):</p>
<p>self.log_text.insert(tk.END, message + "\n")</p>
<p>self.log_text.see(tk.END)</p>
<p>self.root.update()</p>
<p>def execute_process(self):</p>
<p># 检查路径是否都已选择</p>
<p>if not all([self.articles_path.get(), self.images_path.get(), self.output_path.get()]):</p>
<p>messagebox.showerror("错误", "请选择所有必要的文件夹路径")</p>
<p>return</p>
<p># 清空日志</p>
<p>self.log_text.delete(1.0, tk.END)</p>
<p>try:</p>
<p>result = match_and_insert_images(</p>
<p>self.articles_path.get(),</p>
<p>self.images_path.get(),</p>
<p>self.output_path.get(),</p>
<p>log_callback=self.log</p>
<p>)</p>
<p>messagebox.showinfo("完成", result)</p>
<p>except Exception as e:</p>
<p>messagebox.showerror("错误", str(e))</p>

<p>def match_and_insert_images(articles_folder, images_folder, output_folder, log_callback=print):</p>
<p>try:</p>
<p>if not os.path.exists(output_folder):</p>
<p>os.makedirs(output_folder)</p>
<p># 获取所有文章文件</p>
<p>article_files = {}</p>
<p>log_callback("文章文件列表：")</p>
<p>for file in os.listdir(articles_folder):</p>
<p>if file.endswith('.txt'):</p>
<p>name = os.path.splitext(file)[0]</p>
<p>article_files[name] = os.path.join(articles_folder, file)</p>
<p>log_callback(f"  - {name}")</p>
<p># 获取所有图片链接文件</p>
<p>image_files = {}</p>
<p>log_callback("\n图片链接文件列表：")</p>
<p>for file in os.listdir(images_folder):</p>
<p>if file.endswith('.txt'):</p>
<p>name = os.path.splitext(file)[0]</p>
<p>image_files[name] = os.path.join(images_folder, file)</p>
<p>log_callback(f"  - {name}")</p>
<p># 显示匹配结果</p>
<p>log_callback("\n成功匹配的文件：")</p>
<p>matched_files = set(article_files.keys()) &amp; set(image_files.keys())</p>
<p>for name in matched_files:</p>
<p>log_callback(f"  - {name}")</p>
<p>log_callback("\n未匹配的文章文件：")</p>
<p>unmatched_articles = set(article_files.keys()) - set(image_files.keys())</p>
<p>for name in unmatched_articles:</p>
<p>log_callback(f"  - {name}")</p>
<p>log_callback("\n未匹配的图片链接文件：")</p>
<p>unmatched_images = set(image_files.keys()) - set(article_files.keys())</p>
<p>for name in unmatched_images:</p>
<p>log_callback(f"  - {name}")</p>
<p># 匹配文件并处理</p>
<p>processed_count = 0</p>
<p>for name in matched_files:</p>
<p>output_file = os.path.join(output_folder, f"{name}.md")</p>
<p># 调用原有的插入图片函数</p>
<p>result = insert_images_into_text(</p>
<p>article_files[name],</p>
<p>image_files[name],</p>
<p>output_file</p>
<p>)</p>
<p>if result == "success":</p>
<p>processed_count += 1</p>
<p>log_callback(f"成功处理: {name}")</p>
<p>else:</p>
<p>log_callback(f"处理失败: {name}, 错误: {result}")</p>
<p>return f"完成处理 {processed_count} 个文件"</p>
<p>except Exception as e:</p>
<p>return f"错误: {str(e)}"</p>

<p>if name == "__main__":</p>
<p>root = tk.Tk()</p>
<p>app = ImageInserterGUI(root)</p>
<p>root.mainloop()</p>
<h1>脚本链接：</h1>
